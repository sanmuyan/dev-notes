# 操作系统

## 操作系统进程

### 进程

由代码组成的可执行文件程序，运行后装载到内存，CPU执行程序的指令，那么这个运行中的程序就是进程

### 进程状态

- 运行状态  
该时刻进程占用CPU
- 就绪状态  
可运行但因为其他进程正在运行而暂停停止
- 阻塞状态  
该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行

### 进程控制结构

在操作系统中，是用进程控制块（process control block，PCB）数据结构来描述进程的

- 进程描述信息  
包括进程标识符、用户标识符
- 进程控制和管理信息  
进程当前状态、进程优先级
- 资源分配清单  
进程分配的虚拟内存和打开文件的列表和所使用的 I/O 设备信息
- CPU相关信息  

### PCB队列

- 将所有处于就绪状态的进程链在一起，称为[就绪队列]
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种[阻塞队列]

### 进程控制

- 创建进程
- 终止进程
- 阻塞进程
- 唤醒进程

### 进程调度

选择一个进程运行这一功能是在操作系统中完成的，通常称为[调度程序]

- 调度时机  
发生进程状态转换时触发调度
- 调度算法分类  
非抢占式调度算法：挑选一个进程运行一直到进程阻塞或者阻塞  
抢占式调度算法：调度程序给进程运行分配时间片段，如果时间片段结束该进程还在运行，则会发生[时钟中断]挂起该进程
- 调度原则
CPU利用率：调度程序应该确保CPU在繁忙状态  
系统吞吐量：即单位时间内CPU完成计算的进程数，长作业的进程会长时间占用CPU时间，因此会降低系统吞吐量  
周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好  
等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意  
响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要
- 调度算法
 先来先服务调度算法
 最短作业优先调度算法
 高响应比优先调度算法
 时间片轮转调度算法
 最高优先级调度算法
 多级反馈队列调度算法

### 上下文切换

CPU从一个进程切换到另外一个进程，称之为上下文切换。上下文切换需要CPU在寄存器中设置程序计数器，计数器存储了正在执行指令的位置、下一条指令的位置。操作系统的维度上下文包括了虚拟内存、栈、全局变量

### 上下文切换的原因

- 公平调度  
CPU计算时间被分为多个时间片段，当一个进程的时间片段用完时
- 系统资源不足  
无法满足进程的运行条件，比如内存不足
- 进程睡眠  
进程调用系统睡眠函数主动挂起
- 硬件中断  
发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序

### 并发

CPU核心同时只能执行一个进程的指令，CPU在某个时间范围不断切换不通进程的指令，因为CPU“很快”，所以给人的感觉就是在并发`

### 线程

进程中可以同时存在多个线程，各个线程之间可以并发执行，线程共享进程的堆、代码区、全局变量，线程栈和寄存器不共享

### 线程和进程的区别

进程是资源分配单位（内存、打开文件），线程是CPU执行单位  
进程是一个完整的资源平台，线程只独享部分资源，如寄存器和栈  
线程比进程创建的开销更小，因为不需要创建共享部分的资源

### 线程的实现方式

- 用户线程  
由用户态的线程库创建  
优点：由于线程库大多由编程语言实现和管理，所以可以用于跨平台支持不同的操作系统  
由于用户态线程的切换都是有线程库完成，因此没有用户态内核态切换的开销  
缺点：当一个线程阻塞时默认情况下整个进程都会阻塞，因为用户态的线程没有权限打断正在运行中的线程。操作系统才有特权打断正在运行的线程但是用户态线程不由操作系统管理
- 内核线程  
在内核中实现并管理的线程  
优点：某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行  
缺点：线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大

### 进程间通信

- 管道
所谓的管道，就是内核里面的一串缓存,从管道一端写入，另一端读取，比如 `cat test.txt |grep "error"`  
其原理就是`cat gerp`两个命令属于一个父进程，管道其实就是一个文件，子进程分别有文件描述符指向这个文件对象
- 消息队列  
A进程给B进程发送数据，只需要将数据发送到消息队列即可返回，B读取数据后内核会销毁消息队列  
消息队列不适合大数据拷贝，因为它有数据大小限制，同时消息队列因为在内核态维护，存在跨态开销
- 共享内存  
现代操作系统一般采用虚拟内存，虚拟内存具体指向物理内存地址，每个进程都有自己独立的虚拟内存  
共享内存就是开辟一个共享的虚拟内存指向对应的物理内存地址，共享内存不用拷贝数据，速度很快
- 信号量  
如果两个进程同时操作共享内存，必然会导致数据错乱,信号量就实现了这一保护机制，主要用于实现进程间的互斥与同步  
信号量<0表示共享内存被占用；信号量=0表示共享内存可用；P操作信号量-1；V操作信号量+1
信号量就实现了这一保护机制，主要用于实现进程间的互斥与同步  
互斥：初始信号量=1，执行P操作信号量=0，A进程可以操作共享内存，执行P操作信号量=-1，此时B进程也要操作共享内存，那么B就会被阻塞，A进程操作完共享内存，执行V操作，信号量=0，唤醒B进程操作共享内存

假如A进程负责生产数据，B进程负责读取数据，那如何保证B进程一定在A进程准备好数据之后执行？  
同步：初始信号量=0，执行P操作信号量=-1，B进程此时无法操作共享内存被阻塞，A进程准备好数据放入共享内存，执行V操作，信号量=0，此时唤醒B进程读取共享内存

- 信号  
比如`kill -15 PID`是发送 `SIGTERM信号`，`kill -9 PID`是`SIGKILL信号`  
SIGTERM 信号是通知进程停止，进程可以捕捉SIGTERM 信号，也可以忽略SIGTERM 信号
SIGKILL 信号无法被忽略
- Socket
上面的进程通信方式都是本机的进程通信，如果需要跨主机通信那就要使用Socket封装TCP/IP进行网络通信  
Socket还可以进程本地进程通信，本地Socket因为不需要使用TCP或UDP所以不需要绑定端口和IP，而是绑定本地文件通过[本地数据报文]的方式传输数据

### 硬件中断

 中断是指当发生某个事件时，CPU暂停后续指令执行转而去处理新的指令

可以设想一下当我们用键盘打字的时候，按下某个键后，假设CPU先执行原先的一批指令，这一批指令需要10完成，10秒后打的字才在屏幕上出现，这显然是不能接受的，我们的需求是当我打字的时候要“马上”看到处理结果  

CPU如果主动监控硬件的行为这显然很耗费资源，实际上CPU只要开放一个接口，硬件通过这个接口打断CPU的行为就是[硬件中断]  

键盘、鼠标、网卡等硬件都有自己IRQ(中断请求)，中断请求会存储在中断寄存器中，CPU在每个指令周期执行完之后，会去查看中断寄存器的状态，如果有中断，那么就跳转到中断处理程序

### 软件中断

中断是一种异步的事件处理机制，可以提高系统的并发处理能力  
中断处理程序在响应中断时，不能同时处理其它中断请求，如果中断处理时间过长，中断程序会关闭未处理的中断，造成中断丢失

以取快递为例：你周末在家中处理家务，同时你有两个重要的快递今天也会送到，快递员给你打电话[中断请求]，你不得不放下还没有做完的家务，接通快递员电话[处理中断]，快递员不熟悉小区找不到你家，这时候第二个快递员也打你电话，这时候你还在和第一个快递员沟通怎么找到你家的问题，第二个快递员不能联系到你直接走了[中断丢失]  

Linux为了处理中断丢失的问题，为中断设计了步骤

- 上半部  
对应硬中断，由硬件触发中断，用来快速处理中断。主要处理跟硬件紧密相关的或时间敏感的工作，比如网卡收到一个网络包A，内核调用中断程序把网络包A先放进内存，此时网卡收到网络包B，内核同样也会调用中断程序把网络包B放入内存
- 下半部  
对应软中断，由内核触发中断，用来异步处理上半部未完成的工作

### 死锁、悲观锁、乐观锁

#### 死锁

死锁只有同时满⾜以下四个条件才会发⽣

- 互斥条件  
线程1占用A资源，别的线程就不能占用A资源
- 持有并等待条件
线程1占用A资源，线程2占用B资源，线程1需要占用B资源后才能释放A资源，线程2占用A资源后才能释放B资源  
- 不可剥夺条件
线程1占用A资源，在⾃⼰使⽤完之前不能被其他线程获取
- 环路等待条件  
死锁发⽣的时候，两个线程获取资源的顺序构成了环形链

#### 悲观锁

资源被多个线程同时修改的概率比较多，所以访问资源前需要先加锁

#### 乐观锁

资源被多个线程同时修改的概率较小，修改资源前不加锁直接修改，修改后验证是否有其它线程先一步修改，如果是直接放弃修改

## 操作系统内存

### 虚拟内存

进程不能直接操作物理内存，这样很不安全，操作系统会给每个进程分配独立的[虚拟内存]空间，虚拟内存会映射到物理内存地址。CPU内存管理单元有虚拟内存地址映射表，CPU处理数据的时候会把虚拟地址转换成物理内存地址

### 内存分段

程序是由又干个逻辑组成的，由代码分段、数据分段、栈段、堆段组成，这4个分段的内存是连续的，不同的段是有不同的属性的，所以就用[分段]（Segmentation）的形式把这些段分离出来

### 内存碎片

假设有1G的物理内存，游戏分配512MB、浏览器分配128MB、微信分配256MB，关闭了浏览器，目前还剩余256MB，但是256MB内存很可能是由两段不连续的128MB内存组成的，也就是说虽然剩余256MB内存，但是仍然不能打开一个占用200MB的进程

### 内存交换

操作系统映射硬盘的一部分空间，开辟一块内存交换区(`Swap`)，可以先把微信写入交换分区，此时内存剩余的512MB空间就是连续的了，再把微信装回内存，剩余的256MB空间就是连续的了

### 内存分页

分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题  
内存分页很好的解决了这些问题，分页就是把虚拟内存分成更小的单位，比如4KB，[页表]负责映射虚拟内存地址对应的物理内存页表，这样一来将程序加载到内存时不必全部加载，释放内存时也不必全部释放，交换内存是也不必全部交换

### 多级页表

在32位的环境下，虚拟地址空间共有4GB，假设一个页大小有4KB，那就需要大约100万个页，每个[页表]需要4个字节存储，那么就需要4MB内存  
要知道每个进程都自己的虚拟地址池，如果有100个进程那么就需要400MB的内存空间存储页表  
多级页会分把100万个[页表]分为：

- 一级页表分为1024个，也就是1024个一级页表会覆盖整个虚拟内存空间
- 每个一级页表包含1024个二级页表
程序一般不会使用全部的虚拟内存，所以二级页表也就可以按需创建

### 段页式内存管理

将代码分段、数据分段、栈段、堆段分页使用

### Linux内存管理

Linux 系统中的每个段都是从0地址开始的整个4GB虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址）

进程在用户态时只能访问用户态的内存空间，进入内核态后才能访问内核空间的内存  
进程用户态的虚拟内存空间是独立，每个进程关联的内核态虚拟内存空间会映射到相同的物理内存地址

## Linux 文件系统

### 文件

 Linux ⽂件系统会为每个⽂件分配两个数据结构：索引节点 `inode` 和⽬录项 `directory entry`，它们主要⽤来记录⽂件的元信息和⽬录层次结构

- 索引节点  
 ⽤来记录⽂件的元信息，⽐如 inode 编号、⽂件⼤⼩、访问权限、创建时间、修改时间、数据在磁盘的位置
索引节点是⽂件的唯⼀标识，它们之间⼀⼀对应，也同样都会被存储在硬盘中，所以索引节点同样占⽤磁盘空间
- ⽬录项  
⽤来记录⽂件的名字、索引节点指针以及与其他⽬录项的层级关联关系。多
个⽬录项关联起来，就会形成⽬录结构，但它与索引节点不同的是，⽬录项是由内核维护的⼀个数据
结构，不存放于磁盘，⽽是缓存在内存

### 虚拟⽂件系统

⽂件系统的种类众多，⽽操作系统希望对⽤户提供⼀个统⼀的接⼝，于是在⽤户层与⽂件系统层引⼊了中间层，这个中间层就称为虚拟⽂件系统 `VFS`

应用程序->系统调用->虚拟文件系统->文件系统(EXT4、XFS)->缓冲区->磁盘

### ⽂件描述符

打开了⼀个⽂件后，操作系统会跟踪进程打开的所有⽂件，所谓的跟踪呢，就是操作系统为每个进程维护⼀个打开⽂件表，⽂件表⾥的每⼀项代表 `⽂件描述符` ，所以说⽂件描述符是打开⽂件的标识

每⼀个进程都有⼀个数据结构 `task_struct` ，该结构体⾥有⼀个指向 `⽂件描述符数组` 的成员指针  
该数组⾥列出这个进程打开的所有⽂件的⽂件描述符，数组的下标是⽂件描述符，是⼀个整数，⽽数组的内容是⼀个指针，指向内核中所有打开的⽂件的列表，也就是说内核可以通过⽂件描述符找到对应打开的⽂件

### I/O 多路复⽤

#### select/poll

select 实现多路复⽤的⽅式是，将已连接的 Socket 都放到⼀个⽂件描述符集合，然后调⽤ select 函数将⽂件描述符集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个⽂件描述符集合拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，然后再对其处理

#### epoll

epoll 在内核⾥使⽤ `红⿊树` 来跟踪进程所有待检测的⽂件描述字，把需要监控的 socket 通过
epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是
O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个socket 集合，只需要传⼊⼀个待检测的 socket，减少了内核和⽤户空间⼤量的数据拷⻉和内存分配

epoll 使⽤事件驱动的机制，内核⾥维护了⼀个链表来记录就绪事件，当某个 socket 有事件发⽣
时，通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率
